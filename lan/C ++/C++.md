# 程序结构：

``` c++
#include <iostream> //预处理命令
/*

*/
using namespace std; //命名空间

int main()
{
    /*
     cout：预定义对象，iostream的实例，连接到标准输出设备，通常与刘插入运算符<<结合使用
     cin：预定义对象，iostream实例，连接到标准输入设别，通常是键盘，常与流提取运算符>>集合使用
     cerr:标准错误流
     */
   cout << "Hello World"; // 输出 Hello World
   return 0;
}
```

# C程序的执行过程
``` mermaid
flowchart LR
a[.c]-->|预处理|b[.i]
b-->|compiler|obj[目标代码.o]
lib[库代码.lib]-->link
obj-->link[连接器]
start[启动代码]-->link
link-->|链接|exe[可执行程序]

```


| 过程   | 功能                        | 输出结果                                     |
| ------ | --------------------------- | -------------------------------------------- |
| 预处理 | 宏定义:将宏替换为对应的代码 | 生成`.i`的文本文件,不同平台下,该文本有所不同 |
|        | 文件包含                    |
|        | 条件编译等                  |


## 预处理阶段
### include-文件包含
`#include`叫做文件包含命令,用来引入对应的`.h`头文件,将头文件中的内容插入到命令所在位置,实质是一种替换.

### define宏定义
`#define`:宏定义命令,格式为`#define NAME STRING`,`STRING`可以是任意字符,甚至是一段代码.在编译阶段,编译器会将`NAME`宏替换为`STRING`文本.

注意:**宏实质只是文本替换**,因此定义函数时,许哟啊
#### 使用宏定义代码段
``` C++
#include <stdio.h>
#define PR printf("hello world\n");

int main(void){
  PR
}
```

#### 定义带参数的宏

定义带参数的宏的语法一般为:`#define 宏名(形参列表) 字符串`,而在调用该宏的时候,一般写法为:`宏名(实参列表);`

有参数的话,编译阶段,也会将参数替换为原来的文本.

EXAMPLE:
``` C++
#define M(y) y*y+3*y  //宏定义

int main(){
  k=M(5);  //宏调用
}
```

#### 带参数宏定义与函数的区别:
##### 使用函数定义:
``` C++
#include <stdio.h>
int SQ(int y){
  return ((y)*(y));
}
int main(){
    int i=1;
    while(i<=5){
        printf("%d^2 = %d\n", (i-1), SQ(i++));//因为c语言函数从右往左运行,因此先执行i++,再执行i-1(参数也是从右往左载入)
    }
    return 0;
}
/**
运行结果：
1^2 = 1
2^2 = 4
3^2 = 9
4^2 = 16
5^2 = 25
*/
```
##### 使用带参数宏定义
``` C++
#include <stdio.h>
#define SQ(y) ((y)*(y))
int main(){
    int i=1;
    while(i<=5){
        printf("%d^2 = %d\n", i, SQ(i++));
        // printf("%d^2 = %d\n", i, (i++)*(i++));// 经预处理后的代码
    }
    return 0;
}
/**
3^2 = 2
5^2 = 12
7^2 = 30
*/
```


带参数宏定义与函数的区别参见:[C语言带参宏定义和函数的区别](http://c.biancheng.net/view/1983.html)



### #if条件编译
不同平台,要想实现相同功能,需要不同的函数.

**根据不同的情况编译不同的代码,产生不同目标文件的机制,叫做条件编译**

`#if`后面跟整数常量表达式,`#ifdef`,`#ifndef`后跟跟宏

### 预处理命令总结

| 指令     | 说明                                                      |
| -------- | --------------------------------------------------------- |
| #        | 空指令，无任何效果                                        |
| #include | 包含一个源代码文件                                        |
| #define  | 定义宏                                                    |
| #undef   | 取消已定义的宏                                            |
| #if      | 如果给定条件为真，则编译下面代码                          |
| #ifdef   | 如果宏已经定义，则编译下面代码                            |
| #ifndef  | 如果宏没有定义，则编译下面代码                            |
| #elif    | 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 |
| #endif   | 结束一个#if……#else条件编译块                              |

#### #if条件编译
``` c
#if 整型常量表达式1
    程序段1
#elif 整型常量表达式2
    程序段2
#elif 整型常量表达式3
    程序段3
#else
    程序段4
#endif
```

根据条件编译程序段

#### #ifdef
使用`#ifdef`可以根据是否有定义宏来进行编译.
``` c++
#ifdef  宏名
    程序段1
#else
    程序段2
#endif
```

翻译过来就是:
``` c
if(已定义宏)
  编译程序段1
else
  编译程序段2
```

#### #ifndef
用法和`#ifdef`相反,表示在没有定义宏的时候进行编译.

# 命名空间
为了保持兼容性,需要保留原来C中的头文件,如`stdio.h`,仍然可以继续使用.但是为了c++的发展,需要编写新的功能.因此就将原本的库复制了一份,为了避免头文件重名,对头文件的命名做出调整,去掉了`.h`后缀名.

标准C头文件stdio.h和stdlib.h等继续被支持,但是不再`std`命名空间中.

**
可以发现，对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。
**

在大型的工程中,不宜全局范围内声明命名空间.
``` c++
#include <iostream>
//声明全局命名空间std
using namespace std;

void func(){
    //局部范围内声明使用命名空间
    using namespace std;
    cout<<"hello world"<<endl;
}
int main(){
    cout<<"C语言中文网"<<endl;
    func();
    return 0;
}
```
# 内存管理
c语言中,使用`malloc()`和`free()`函数来申请和释放堆内存.在C++中新增了`new`和`delete`关键字来管理内存--new和delete会自动调用**构造函数**和**析构函数**.
# inline内联函数
内联函数声明:`inline void name(){};`
特点:
类似于宏展开,在编译时将内联函数声明替换为内联函数体.优点是:避免了函数调用,减小了各种开销. 缺点是:增加了编译后的体积.

因此,内联函数适合于简单,频繁应用到的函数,简单函数,过程调用开销占函数整个运行时间比例大,有实际意义;但是如果是复杂函数,则过程调用的开销相对于整个函数执行时间的比例小,但是呢,反而会增加编译后的体积.因此:内联函数适合用于小而简单,频繁使用的函数.

可以使用内联函数替代宏.

``` c++
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
```

# 面向对象：
继承：c++使用**：**来表示继承（extends）

命名空间：
使用“::”符号表示引用命名空间中的成员

类与命名空间
| 区   | 类  | 命名空间                                                    |
| ---- | --- | ----------------------------------------------------------- |
| 作用 |     | C++没有package这一概念，使用命名空间相当于起到package的作用 |