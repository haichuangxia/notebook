# 数组

使用数组名作为函数参数

将数组首地址作为实参进行传递

定义对象数组时,会调用默认的构造函数进行初始化

 数组名做实参,实际就是数组首地址作实参,形参需要用指针。此时就需要使用指针访问数组元素。如果要用数组作为实参,定义函数时,其形参需要使用指针。

# 指针

## 指针常量与指向常量的指针

只读指针--指向常量的指针

``` c++
int a;
const int* p1=&a;//虽然a为变量,p1也是变量,但是不能通过p1修改变量a的值。
int* const p2=&a;//p2是常量,但是可以p2修改a的值。

```
因此c语言中，匹配和运算的方向是从右至左的，const在谁前面表示谁是常量。

## 指针的算数运算
| 形式   | 等价形式 | 含义                                                         |
| ------ | -------- | ------------------------------------------------------------ |
| *p++   | *(p++)   | 表示先取得第 n 个元素的值，再将 p 指向下一个元素             |
| *++p   | *(++p)   | 会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值 |
| (*p)++ |          | 会先取得第 n 个元素的值，再对该元素的值加 1                  |

## 二级指针
``` c++

int **ptr=NULL;
// *ptr表示获取ptr这一个二维指针所指的对象，也就是一维指针
*ptr=new int[5];

```

二维指针:指向指针的指针。二维指针的含义是:**变量ptr是一个指针,其内容也是一个指针**。因此,如果要修改ptr的值时,就需要使用**指针运算符***。

指针运算符*:当已具有一个指针，并且希望**获取它所引用的对象**时，使用间接运算符 *（indirection operator），有时候这会被称为**解引用运算符（dereferencing operator）**。其作用为：获得指针所指向的对象。

定义指针的时候用了多少个指针运算符*，该指针就是多少级的。如`int **p`是二级指针，但是`int (*p)[5]`这一数组指针，指向的是一个二维数组，但是p这个指针变量还是一级指针。



## 指针总结

常见指针变量的定义

| 定  义       | 含  义                                                       |
| ------------ | ------------------------------------------------------------ |
| int *p;      | p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 |
| int **p;     | p 为二级指针，指向 int * 类型的数据。                        |
| int *p[n];   | p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]); |
| int (*p)[n]; | p 为二维数组]指针。                                          |
| int *p();    | p 是一个函数，它的返回值类型为 int *。                       |
| int (*p)();  | p 是一个函数指针，指向原型为 int func() 的函数。             |

关于使用指针的一些规则：

1. 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。
1. 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。
1. **使用指针变量之前一定要初始化**，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。
1. 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。
1. 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。

# 数组和指针的区别

数组名可以看作一个指针常量，即指针的值不会变，即数组名指向的内存区间不会变。下例体现了数组和指针作为函数参数的区别：数组名是一个常量，因此不能改变所指向的对象，当一个函数需要改变指针所指对象时，就不能使用数组，而只能使用指针。

``` c
#include <openssl/evp.h>
#include <stdint.h>
#include <string.h>

void handleErrors()
{
}

// 根据输入计算哈希值,  使用md5，输出128位的哈希值，因为使用的是aes-128
void digest_message(const unsigned char *message, size_t message_len, unsigned char **digest, unsigned int *digest_len)
{
    EVP_MD_CTX *mdctx;

    if ((mdctx = EVP_MD_CTX_new()) == NULL)
        handleErrors();

    if (1 != EVP_DigestInit_ex(mdctx, EVP_md5(), NULL))
        handleErrors();

    if (1 != EVP_DigestUpdate(mdctx, message, message_len))
        handleErrors();

    if ((*digest = (unsigned char *)OPENSSL_malloc(EVP_MD_size(EVP_md5()))) == NULL)
        handleErrors();

    if (1 != EVP_DigestFinal_ex(mdctx, *digest, digest_len))
        handleErrors();

    EVP_MD_CTX_free(mdctx);
}
int main()
{
    uint8_t group = 2;
    unsigned char extendgroup[1] = {0};
    memcpy((void *)extendgroup, (void *)&group, 1);
    int msglen = 1;
    unsigned char *digest = NULL;
    // unsigned char digest[16] = {0};
    unsigned int digestlen = 0;
    digest_message(extendgroup, msglen, &digest, &digestlen);
    // printf("the hash of message is %x\n", digest[0]);
    printf("the hash of message is %x\n", *digest);
}
```

## 二级指针与二维数组

不能使用二维数组名赋值给二级指针。解释如下：[为什么二维数组名不能赋值给二级指针 - 心媛意码 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Stephen-Qin/p/10502773.html)

``` c
int a[2][2];
// a的地址就是a[0]的地址，也是a[0][0]的地址
int **p；
// p是一个指针，指向的对象也是一个指针
```



# 与数组有关的指针应用

## 指针数组

使用多态的时候,还是需要使用指针的。

``` c++
Point *pa[2];
```

有**`[]`**表明首先是一个数组,**`Point *`**表示数据元素类型是一个**`Point`**类型的指针

**[]**的优先级高于**指针运算符* **。

考虑一个情况,一个矩阵,行经常发生交换。此时定义一个一维的指针数组,要交换两行只需要交换指针数组对应位置的元素就可。

## 指向数组的指针

下面这行语句,定义一个指针,来指向一个数组。

``` c++
int (* ptr)[10] = NULL;// 一个指针，指向一个有是个int元素的数组
int * ptr[10]=NULL;//一个数组，数组的内容是指针
```





能不用指针最好不用指针

## 函数,对象有关的指针应用

### 指针作为函数参数

当引用和指针都能作为参数时,优先选择引用

以指针作为函数参数的两种情况

### 指针作为函数返回值

错误的使用

不要返回非静态,非全局的变量地址作为指针。如果变量销毁了,那么返回的地址就全无意义。

正确例子:返回的指针在主函数中一定有效



new得到的,不用的时候需要用delete手动删除。如果程序一直执行,只new不delete,迟早崩溃



### 函数指针

指针指向的对象可以是函数,因为存储程序,指针指向内存中,存储程序入口的地址,是函数代码的首地址。

函数指针是c语言中实现函数回调的方法。复杂函数时,建议使用函数对象进行回调。



使用函数指针实现函数回调的实例:
函数回调:定义的时候,并不知道后面使用哪个具体的函数


delete会释放掉通过new申请来的内存空间



