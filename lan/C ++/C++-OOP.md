# 类和对象

## 类的定义

类定义的通常结构为:

![image-20221029183924272](https://qingbin.oss-cn-chengdu.aliyuncs.com/img/2023/20230217114933.image)

``` C++
class Box
{
private: // 访问修饰符
    // 定义数据类型
    double length;
    double breadth;
    double height;

public:
    // 定义类型成员
    typedef int a_type;
    // 成员函数声明
    double get(void);
    void set(double len, double bre, double hei);
};
// 成员函数定义
double Box::get(void)
{
    return length * breadth * height;
}

void Box::set(double len, double bre, double hei)
{
    length = len;
    breadth = bre;
    height = hei;
}
```

### 成员函数的两种定义方式

#### 在类体内定义

在类体内定义的函数默认是**内联函数**.

内联函数:在编译时候,若普通函数`A()`调用了内联函数`inline B()`,则在编译时,在`A()`中,会使用`B()`的函数体来替换原本使用`B()`的地方.而普通函数则需要在运行`A()`时,才会使用函数调用机制进行调用.内联函数是一种空间换时间的方法,通过使用内联函数,减少了函数调用次数,但是却增加了编译后的体积(只要有调用内联函数`B()`的地方,就会进行展开).

内联函数和宏定义共同之处是都需要在使用时进行展开,而不是进行函数调用.区别在于:
1: 时间不同,宏定义在预处理时进行替换,内联函数在编译时进行替换
2: 功能不同:内联函数会检查参数类型，所以更安全

*内联函数用的地方不多，它会将函数调用处用函数体替代，所以一般在类体内部对成员函数作声明，而在类体外部进行定义*.

如果函数体较小,且用的比较多,那么定义内联函数也挺好.
#### 在类体外通过`::`定义
`::`被称为**域解析符**（也称**作用域运算符**或**作用域限定符**），用来连接类名和函数名，指明当前函数属于哪个类。(命名空间也是用这个解析符)

``` c++
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;
    //成员函数
    void say();  //函数声明
};
//在类体外进行函数定义
void Student::say(){
    cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
}
```

### 构造函数的两种写法
构造函数是在已经分配内存之后,对类的成员进行初始化的操作.类的构造函数可以使用两种方式进行定义:

- 初始化:随着对象的诞生一同进行
- 赋值:对象产生之后给予一个新的值

1. 常规写法(赋值)
2. 初始化列表

#### 常规写法
``` c++
#include <iostream>
using namespace std;
class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    //声明构造函数
    Student(char *name, int age, float score);
    //声明普通成员函数
    void show();
};
//定义构造函数
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
```
#### 初始化列表写法

``` c++

//采用初始化列表方式定义构造函数
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    //TODO:
}
//定义普通成员函数
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
```

#### 使用两种写法创建对象

``` c++

int main(){
    //在栈上创建对象时向构造函数传参
    Student stu("小明", 15, 92.5f);
    stu.show();
    //在堆上创建对象时向构造函数传参
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();

    return 0;
}
```

#### 两种定义方式的区别
1. 两种方式效率相同,但是如果类有成员**常量**(`const`)或者**引用**成员,就需要使用**初始化列表**方式
2. 初始化常量方式以`:`为标志
3. 初始化列表早于赋值阶段,对象的初始化是通过初始化列表方式进行的,儿对象的赋值才是通过构造函数的实现体.这也就解释了,为什么类如果有常量成员,就需要使用初始化列表的方式

### 成员函数的定义规则

#### 常量成员函数
如果将`const`关键字放在函数的参数列表后面,表示该函数为**常量成员函数**.example:`int max(a,b) const{}`.常量成员函数的一个最重要的特点就是:无法通过常量成员函数来修改成员变量的值.如果要通过常量成员函数修改成员变量，则编译器会报错．

const对象**只能**调用常量成员函数.

建议:但凡是不能要求修改成员变量的函数,都设置成常量成员函数.

## 构造函数

构造函数在创建对象时被调用,讲对象**初始化**为一个特定的初始状态.

| 构造函数类型 | 特点                              |
| ------------ | --------------------------------- |
| 复制构造函数 | 通过复制的方式构造新对象          |
| 移动构造函数 | 通过移动数据类型的方式构造新对象. |
|              |                                   |



### 默认构造函数

默认构造函数:<font color=green>调用时可以不需要实参的构造函数</font>

默认函数有两种形式,分别为:

1.  无参的构造函数:如:`Clock()`
2.  参数全部有默认值的构造函数,如:`Clock(int a=0,int b=0)`

此两种方式是冲突的,只能存在一种.

如果程序员没有定义构造函数,则编译器会自动生成一个无参的构造函数.如果程序员定义了构造函数,则系统默认不会再生成默认的构造函数.

``=delete`放在函数后面,表示禁止编译器生成默认函数.

如果已经自定义了构造函数,但是还想让编译器生成一个默认的无参的构造函数,此时就需要用到`=default`.如:

``` c++
class Message
    {
    private:
        int subset_num;
    public:
        Message() = default;
	}
```

加`=default`的作用为:在调用无参的构造方法时编译器才会生成这样一个无参的构造方法,如果没有调用,则不会生成.因此`Message(){}`和`Message()=default`有本质区别,区别在于该构造函数是否一定存在.

如果没有定义无参的构造函数,则`Clock c2`这种调用无参的构造方法,在栈内定义对象的语句就会报错.

### 复制构造函数

该种复制构造函数,使用已经存在的对象,去初始化新的对象.隐含生成的复制构造函数可以实现对应的数据成员一一复制.

#### 调用复制构造函数的三种情况

| 情形                                   | 原因                                                      | 实例                            |
| -------------------------------------- | --------------------------------------------------------- | ------------------------------- |
| 使用一个类的对象初始化该类的另一个对象 |                                                           | 这两种写法完全相同,只是写法不同 |
| 函数参数为对象且为值传递时             | 值传递,传递是一个复制品                                   |                                 |
| 返回值时类的对象                       | 函数局部变量在调用后就会消亡,因此return的其实是一个复制品 |                                 |


#### 浅复制：

使用默认生成的复制构造函数构造对象的方式叫做浅复制。

> 在未自定义拷贝构造函数时，在复制对象时调用默认的拷贝构造函数时，进行的时浅拷贝。容易发生内存泄漏。如果类成员是一个指针，那么浅拷贝只会复制指针，而不会复制指针指向的内容。

在下例中，使用浅复制的方法复制具有指针成员的对象时会出现的资源多次回收的问题。

``` c++
 class A
{
public:
   int *a;  
}
A a1;
A b1=a1;
// b1.a与a1.a指向同一个地址，销毁b1和a1的时候就会对同一个地址进行两次回收，因此第二次回收就会报错
```
一般来说,定义复制构造函数时,为了避免修改原本的对象,会加const关键字。例如:对于类Point,编译器隐含生成复制构造函数等同于以下写法:
``` c++
A::A(const A& obj){
    a=obj.a;
}
```



#### 深复制：

>深拷贝即调用的自定义的拷贝构造函数，不但对指针进行拷贝，还对指针指向的内容进行拷贝，拷贝后的指针是指向两个不同地址的指针。

``` c++
 #include <iostream>
using namespace std;

class Student
{
private:
    int num;
    char *name;
public:
    Student();
    ~Student();
    Student(const Student &s);//拷贝构造函数，const防止对象被改变
};

Student::Student()
{
    name = new char(20);
    cout << "Student" << endl;

}
Student::~Student()
{
    cout << "~Student " << (int)name << endl;
    delete name;
    name = NULL;
}
Student::Student(const Student &s)
{
    name = new char(20);
    memcpy(name, s.name, strlen(s.name));
    cout << "copy Student" << endl;
}

int main()
{
    {// 花括号让s1和s2变成局部对象，方便测试
        Student s1;
        Student s2(s1);// 复制对象
    }
    system("pause");
    return 0;
}
```

#### 深复制和浅复制的区别与需要自定义拷贝构造函数的三种情况

浅拷贝和深拷贝的不同之处在于：

- 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间。　浅拷贝问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr智能指针，可以完美解决这个问题。
- 深拷贝不仅对指针进行拷贝还对指针指向的内容进行拷贝，经过深拷贝后的指针是指向两个不同地址的指针。

基于这种不同，在以下三种情况下需要考虑自定义拷贝构造函数

1. 复制含指针成员的对象时即用一个类的对象去初始化该类的另一个对象的时候
2. 函数的形参为类对象时。调用函数时会有实参到形参的拷贝此时会调用拷贝构造函数
3. 当函数的返回为类对象时。在函数和返回时会建立一个和类对象一样的临时类对象变量，并将返回的类对象赋值给新创建的类对象，此时会调用拷贝构造函数

### 移动构造函数

#### 使用移动构造函数的情形

很多时候被复制的对象仅仅作复制用,随后销毁.如果是移动已有对象而不是复制对象将大大提高性能.

移动构造函数是基于右值引用的,通过移动数据的方式构造新对象,与复制构造函数类似,但是其效率较高.可以有效利用一个将死的右值,来创建新的对象,以此减少了复制构造函数所带来的时间和空间开销.

**移动构造函数并不会为重新分配内存.****

#### 左值与右值

**右值引用**是为了支持**移动操作**而引入的一种新的引用类型.**右值引用**特性:只能绑定到一个将要销毁的对象.因此,可以将一个右值引用的资源**移动**到另一个对象中.右值引用使用**&&**表示

通过标准库<utility>种的`move()`函数可以将一个左值强行变成右值.被移动的对象不应再使用,需要销毁或者重新赋值.

##### 将右值构造成右值引用

##### 左值构造右值引用



#### 定义移动构造函数

移动构造函数的特点就是参数为一个右值,一般配合`move()`方法,将一个对象变成右值,进行对象所有权的转移,而没有内存的移动或者拷贝.

如一个字符串变量str被move之后,str的内容就为空了.--string本质是一个容器

使用了move函数.表示程序员已经不需要原来的左值了,需要将其进行销毁或者重新赋值.当然,你要是重新用也没有问题,但是这样move就没有啥意义了.

使用move的作用:原始值传递需要三份数据:实参,实参的复制品,需要进行使用实参进行赋值的变量.使用了右值引用之后,

关于move的疑问:

move之后变量的内容会清空,但是该变量还是可以使用,如string可以重新赋值.如果没有发生内存的移动,那原本的内容应该还在原变量的存储空间内?

## 分配内存空间

### 在不同的内存区域定义对象

对于**全局对象**，**静态对象**以及分配在**栈区域**内的对象，对它们的内存分配是在**编译**阶段就完成了，

而对于分配在**堆区域**内的对象，它们的分配是在程序**运行**阶段完成的。

| 定义对象的位置 | 是否使用new | 返回类型   | 分配内存时间 | 特点                                                         |
| -------------- | ----------- | ---------- | ------------ | ------------------------------------------------------------ |
| 栈             | 不用new     | 对象本身   | **编译阶段** | 在栈上创建一个对象,可以直接使用对象.                         |
| 堆             | 使用new     | 对象的指针 | **运行阶段** | 使用`new`关键字在堆上创建对象,使用后需要使用`delete`删除不再使用的对象,避免遗留大量垃圾 |



分配内存时需要确定分配空间的大小,即对象的大小.该大小由编译器根据类数据成员的大小进行分配.



### 使用不同的方式进行对象创建

以此为例,介绍使用隐式调用,显式调用和new()来创建对象

``` c++
class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    //声明构造函数
    Student(char *name, int age, float score);
    //声明普通成员函数
    void show();
};
//采用初始化列表方式定义构造函数
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    //TODO:
}
```
#### 创建对象方式

| 初始化方式       | 使用自定义构造函数                           | 使用默认构造函数               |
| ---------------- | -------------------------------------------- | ------------------------------ |
| 显式调用构造函数 | `Student stu = Student("张三",20,98.0);`     | `Student stu = Student();`     |
| 隐式调用构造函数 | `Student stu("张三",20,98.0);`               | `Student stu;`                 |
| new创建          | `Student *stu =new Student("张三",20,98.0);` | `Student * stu = new Student;` |

#### explicit关键字

`explicit`是用来修饰类的构造函数的,被修饰的构造函数将不能通过隐式调用的方式创建对象,只能通过显式调用等方式创建.

其注意事项为:

1. 只能用于类内部定义的构造函数(默认是内联的)
2. 只能用于单参数的构造函数



## 对象创建过程

``` mermaid
graph
memory(分配内存) -->init[初始化列表实现对象初始化]-->assign(调用构造函数体赋值)
```

## 类的组合

组合类:一个类(A)的成员是另一个类(B)的对象时,则称A为组合类

组合类的构造函数与普通类的构造函数有所不同.其构造函数的基本格式为:

``` c++
类名::类名(对象成员所需的形参，本类成员形参):对象1(参数)，对象2(参数)，......
{
//函数体其他语句
}
```

初始化时,不仅可以初始化基本数据类型,也可以初始化内嵌的对象


# 继承
## 不同继承方式子类的权限
``` C++
class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};
```

继承方式:public,protected,private.默认是private.

不同的继承方式会影响父类的成员在子类中的访问权限,*不同继承方式指定子类继承父类的成员时对成员的最高访问权限*
| 继承方式  | 父类权限  | 子类权限  |
| --------- | --------- | --------- |
| public    | public    | public    |
|           | protected | protected |
|           | private   | 不能继承  |
| protected | public    | protected |
|           | protected | protected |
|           | private   | 不能继承  |
| private   | public    | private   |
|           | protected | private   |
|           | private   | 不能继承  |


使用`using`关键字可以在子类中使用父类中的成员,改变父类中成员访问权限.
``` C++
//基类People
class People {
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
//派生类Student
class Student : public People {
public:
    void learning();
public:
    using People::m_name;  //将protected改为public
    using People::m_age;  //将protected改为public
    float m_score;
private:
    using People::show;  //将public改为private
};
```
## 接口(抽象类)

c++中,使用**抽象类**来实现**接口**.
抽象类:如果类中有至少一个遗憾被声明为**纯虚函数**,则该类就是抽象类.

纯虚函数:函数声明中,原型尾部有`=0`,如:
``` c++
class Box{
public:// 纯虚函数
    virtual double getVolume() = 0;
private:
    double length;      // 长度      
    double breadth;     // 宽度      
    double height;      // 高度};
```
抽象类中,其声明的纯虚函数必须在子类中实现.


## 多继承
``` C++
class D: public A, private B, protected C{
    //类D新增加的成员
}
```

## 子类成员函数规则
子类与父类函数不构成重载,只要函数名相同,无论参数列表如何,子类的函数就会覆盖父类定义的函数.

- 类的构造函数不能被继承,但是可以调用父类的构造函数来简化对象构造过程.
- 父类构造函数优先调用
- 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的
- 调用析构函数时,优先调用子类的析构函数,其次才是父类的析构函数




# 拷贝控制
定义一个类时,有五种特殊的成员函数来控制该类型的**移动**,**拷贝**,**赋值**和**销毁**操作,这些操作叫做**拷贝控制操作**,他们分别是:
1. 拷贝构造函数:使用同类型的另一个对象初始化本对象时所执行的操作
2. 拷贝赋值运算符:将同类型的另一个对象赋予本对象时执行的操作
3. 移动构造函数:使用同类型的另一个对象初始化本对象时所执行的操作
4. 移动赋值运算符
5. 析构函数

## 拷贝,赋值与销毁
### 拷贝构造函数
拷贝构造函数第一个参数**必须**是一个**引用类型**

## 对象移动
在某些情况下,移动而非拷贝对象会大幅度提升性能.

## 右值引用
**右值引用**是为了支持**移动操作**而引入的一种新的引用类型.**右值引用**特性:只能绑定到一个将要销毁的对象.因此,可以将一个右值引用的资源**移动**到另一个对象中.

## 编译器与默认函数
编译器会为类生成一些默认的函数,如默认构造函数,析构函数,默认拷贝构造函数等.即构造函数和拷贝控制函数都会由编译器生成默认的.有时候我们不想编译器生成默认的函数,此时就可以通过一些关键字来管理是否生成默认的函数.

### =default
放在一个类的几类函数后面,表示要求编译器生成一个默认函数

### =delete
放在函数后面,表示禁止编译器生成默认函数.


# 总结
- class内部成员默认是`private`,`struct`成员默认是`public`

# REFERENCE
1. [理解常量成员函数](https://blog.csdn.net/u010248077/article/details/80919111)
2. [C++创建对象详解](https://www.cnblogs.com/yulei0713/p/11326254.html)
3. [C++基础知识（八）---函数返回值（返回值，返回指针，返回对象，返回引用）---引用---复制构造函数（拷贝构造函数）---深复制与浅复制 - long_ago - 博客园 (cnblogs.com)](https://www.cnblogs.com/southcyy/p/10256378.html)
