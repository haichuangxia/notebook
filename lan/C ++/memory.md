程序内存中的堆与栈

| 对比           | 栈                                           | 堆                   |
| -------------- | -------------------------------------------- | -------------------- |
| 管理者         | 操作系统                                     | 程序员               |
| 空间大小       | 一般几MB                                     | 大小自定义,          | 理论上可以达到虚拟内存的大小 |
| 效率           | 硬件支持,效率高                              | 软件实现,效率较低    |
| 存放内容       | 函数返回地址、相关参数、局部变量和寄存器内容 |
| 创建和销毁方式 | 自动创建和销毁                               | 使用malloc()和free() |



#  数据的存储方式对内存读写的影响

小端存储:低位在低字节,如`0x00FF`,`0xFF`存储在`byte[0]`,`0x00`存储在`bytes[1]`

大端存储:与小端存储刚好相反



# Linux下C程序的内存布局(内存模型)

## 内存模型

程序内存在地址空间中的分布情况称为内存模型（Memory Model）。内存模型由操作系统构建，在Linux和Windows下有所差异，并且会受到编译模式的影响，本节我们讲解Linux下32位环境和64位环境的内存模型。

![进程的虚拟地址空间](https://qingbin.oss-cn-chengdu.aliyuncs.com/img/2023/20230310163541.png)

| 内存分区                     | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 程序代码区 (code)            | 存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。 |
| 常量区 (constant)            | 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 |
| 全局数据区 (global data)     | 存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 |
| 堆区 (heap)                  | 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。[malloc()](http://c.biancheng.net/cpp/html/137.html)、[calloc()](http://c.biancheng.net/cpp/html/134.html)、[free()](http://c.biancheng.net/cpp/html/135.html) 等函数操作的就是这块内存，这也是本章要讲解的重点。  注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 |
| 动态链接库（shared library） | 用于在程序运行期间加载和卸载动态链接库。                     |
| 栈区 (stack)                 | 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 |
| 内核虚拟内存                 | 为内核保留，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。 |

**静态数据区**：程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。（Q:返回值的时候会创建临时的对象，该对象是否就在全局数据区？）

> 常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。

**栈**：函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。

**堆**：常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。

注意：函数体内定义的字符串值，如在`example()`内定义`char str[]="1234"`,"1234"是常量，存放在常量区，`str`是一个指针变量,存放在栈区.

SOURCE:https://www.cnblogs.com/zhangjinfu/articles/11275895.html



## 栈与栈溢出

对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，**栈的最大值是针对线程来说的，而不是针对程序**。

栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在 VC/VS 下，默认是 1M，在 C-Free 下，默认是 2M，在 Linux GCC 下，默认是 8M。

提示：**栈也经常被称为堆栈**，而堆依然称为堆，**所以堆栈这个概念并不包含堆**，大家要注意区分。

当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（Stack Overflow）错误。

SOURCE:https://www.cnblogs.com/still-smile/p/14900502.html

# 计算机中对于内存的管理

## MMU部件以及对内存权限的控制

### MMU完成虚拟地址到物理地址的映射

通过页表完成虚拟地址和物理地址的映射时，要经过多次转换，还要进行计算，如果由操作系统来完成这项工作，那将会成倍降低程序的性能，得不偿失，所以这种方式是不现实的。在CPU内部，有一个部件叫做MMU（Memory Management Unit，内存管理单元），由它来负责将虚拟地址映射为物理地址：

### MMU对内存权限的控制

``` c++
#include <stdio.h>
int main() {
    char *str = (char*)0XFFF00000;  //使用数值表示一个明确的地址
    printf("%s\n", str);
    return 0;
}
```

这段代码**不会产生编译和链接错误**，但在运行程序时，为了输出字符串，printf() 需要访问虚拟地址为 0XFFFF00000 的内存，但是该虚拟地址是被操作系统占用的，程序没有权限访问，会被强制关闭。而在Linux下，会产生段错误（Segment Fault）

# 函数调用中的进栈与出栈

本例来源于：[在出栈函数的形参_用一个实例来深入剖析函数进栈出栈的过程](https://blog.csdn.net/weixin_32767591/article/details/113412050)

``` c
void func(int a, int b) { int p = 12, q = 345; }

int main() {
    func(90, 26);
    return 0;
}
```

## 函数参数入栈顺序

- C程序参数入栈顺序：**从右到左**（并非所有语言都是）
- 栈的生长方向：**从高地址向低地址增长**

函数进栈和出栈的变化情况为：

![img](https://qingbin.oss-cn-chengdu.aliyuncs.com/img/2023/20230227110814.png)

函数进栈过程为：

步骤①到⑥是函数进栈过程：
1. main() 是主函数，也需要进栈，如步骤①所示。
2. 在步骤②中，执行语句func(90, 26);，先将实参 90、26 压入栈中，再将返回地址压入栈中，这些工作都由 main() 函数(调用方)完成。这个时候 ebp 的值并没有变，仅仅是改变 esp 的指向。
3. 到了步骤③，就开始执行 func() 的函数体了。首先将原来 ebp 寄存器的值压入栈中(也即图中的 old ebp)，并将 esp 的值赋给 ebp，这样 ebp 就从 main() 函数的栈底指向了 func() 函数的栈底，完成了函数栈的切换。由于此时 esp 和ebp 的值相等，所以它们也就指向了同一个位置。
4. 为局部变量、返回值等预留足够的内存，如步骤④所示。由于栈内存在函数调用之前就已经分配好了，所以这里并不是真的分配内存，而是将 esp 的值减去一个整数，例如 esp - 0XC0，就是预留 0XC0 字节的内存。
5. 将 ebp、esi、edi 寄存器的值依次压入栈中。
6. 将局部变量的值放入预留好的内存中。注意，第一个变量和 old ebp 之间有4个字节的空白，变量之间也有若干字节的空白。为什么要留出这么多的空白，岂不是浪费内存吗？这是因为我们使用Debug模式生成程序，留出多余的内存，方便加入调试信息；以Release模式生成程序时，内存将会变得更加紧凑，空白也被消除。至此，func() 函数的活动记录就构造完成了。可以发现，在函数的实际调用过程中，形参是不存在的，不会占用内存空间，内存中只有实参，而且是在执行函数体代码之前、由调用方压入栈中的。

函数出栈的过程为：
步骤⑦到⑨是函数 func() 出栈过程：

7. 函数 func() 执行完成后开始出栈，首先将 edi、esi、ebx 寄存器的值出栈。
8. 将局部变量、返回值等数据出栈时，直接将 ebp 的值赋给 esp，这样 ebp 和 esp 就指向了同一个位置。
9. 接下来将 old ebp 出栈，并赋值给现在的 ebp，此时 ebp 就指向了 func() 调用之前的位置，即 main() 活动记录的 old ebp 位置，如步骤⑨所示。这一步很关键，保证了还原到函数调用之前的情况，这也是每次调用函数时都必须将 old ebp 压入栈中的原因。最后根据返回地址找到下一条指令的位置，并将返回地址和实参都出栈，此时 esp 就指向了 main() 活动记录的栈顶， 这意味着 func() 完全出栈了，栈被还原到了 func() 被调用之前的情况。

# c中的内存管理

## 使用new和delete动态管理内存

参考：[C++ new和delete（C++动态分配和释放内存） (biancheng.net)](http://c.biancheng.net/view/206.html)

### delete的用法

- **delete**只能用来释放动态分配的内存，也就是只能用来释放使用**new**分配的内存，将内存交还给操作系统。

- **delete**不是删除指针，而是删除指针所指向的内存。

- 使用**delete**释放一个指针，并不会使该指针的值变为 NULL。



# 与内存分配有关的错误

## 动态分配内存与内存泄露

在使用`malloc()`动态分配内存时，如果不使用`free()`进行回收的话，该内存就会一直占用，如果一个程序持续的分配内存而不进行回收的话，内存迟早会被耗光，最终导致死机等情况。使用`malloc()`动态分配内存时容易产生**内存泄漏**：每台电脑都有内存，所有的程序都是先存放到内存里面才能运行。但是某程序将内存空间都占满了，那么其他程序就没有地方存放了，所以内存就好像泄漏了一样。

SOURCE：[动态内存分配，C语言动态内存分配详解](http://c.biancheng.net/view/223.html)

## 野指针与段错误

**野指针**：如果一个指针指向的内存没有访问权限，或者指向一块已经释放掉的内存，那么就无法对该指针进行操作，这样的指针称为野指针（Wild Pointer）。

段错误：

## 存储区越界引用与缓冲区溢出



数组：c对数组的应用不进行边界检查，而局部变量和状态信息（寄存器值，返回指针）都存放在栈中。因此，如果对数组进行了越界的写操作就会破坏在栈中保存的状态信息。因此在程序重新加载寄存器或者执行ret指令时，就会发生严重错误。

## 与new和delete有关的错误

### delete栈中的内存

**delete**只能用来释放动态分配的内存，也就是只能用来释放使用**new**分配的内存，将内存交还给操作系统。

**delete**不是删除指针，而是删除指针所指向的内存。

使用**delete**释放一个指针，并不会使该指针的值变为 NULL。

使用`delete`删除栈中的内存会报错：![image-20230228141533791](https://qingbin.oss-cn-chengdu.aliyuncs.com/img/2023/20230228141534.png)

``` c++
int *p=new int[10];//使用new在堆中分配内存
delete p；//正确：使用delete回收在堆中分配的内存
int a[2];
int *p2=a;
delete p2；// 错误：因为p2所指向的内存是在栈中
```

### delete数组

使用`delete`删除分配的数组时，其用法如下

``` c++
int* p = new int[20];
p[0] = 1;
delete[] p;
```




# REFERENCE

1.  [C语言内存精讲](https://www.jianshu.com/p/8be54dcf9c97)
